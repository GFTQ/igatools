/**

\page example_03 Example 3: traversing elements
\section Introduction
So far we never accessed element-wise data inside an igatools object. In this example we will see how 
to set up loops for traversing the data in an element-by-element fashion.

As already shown, every class is built upon a grid. The grid structure determines not only the 
reference domain but also the element subdivision that can be exploited to perform
the typical tasks of a Finite %Element code. This is the only traversing method
supported by igatools.

There are two ways of setting up an element loop: with or without the use of the
cache. Whenever only integer data are needed (for example dof connectivities or element
indices), then non-cached element loops can be used. This basic element loop
is shown in the body of the function <tt>grid_loop</tt>.

If a quadrature scheme is used and floating point data are 
needed (for example basis function evaluation or quadrature weights),
then the cache mechanism must be set up. We will see this advanced loop in 
the body of <tt>basis_loop_with_cache</tt>.

The motivation of this cache machinery arises from computational efficiency,
one of the main goal for igatools. Unfortunately, efficienct code and clear code 
rarely coincide, thus some tradeoff between a readability and efficiency is necessary.
There is no need to despair: few extra lines of code are needed in order to use the cache.

\section code03 Description of the program

Besides header files that have been already included in the
previous examples, we include few ones for elements and quadrature schemes:
\snippet example_03.cpp includes

We also declare a simple function for the creation of our ol' friend the quarter
annulus (see \ref example_02):
\snippet example_03.cpp quarter_annulus
We will motivate later the grid as input parameter.

We can now start with a simple non-cached element loop over the grid:
\snippet example_03.cpp grid_loop
Each igatools object that can be traversed can be thought (and actually are) as data
container, therefore we only need the element iterators pointing to the beginning
and the end of the container. The associated element accessor <tt>grid_el</tt>
is an instance of the GridElement class.
Once the iterators are set, access to non-cached data follows straightforwardly.

As already stated in the Introduction, few extra lines of code are needed in order
to use the cache, the first of which is the declaration of the <b>chache handler</b>
from the container we want to traverse (in this case a GridHandler from a Grid):
\snippet example_03.cpp basis_loop_start
The <b>cache handler</b> basically performs the following tasks:
  - stores the list of quantities requested by the user. 
    These quantities are always associated to evaluation points over the element;
  - extracts from the container the data that are needed for the computation of the requested quantities;
  - organizes the computation in a way that if the same data is needed multiple times, the
    data is reused and not recomputed;
  - initialize/resize the cache stored in the element;
  - implements and runs the algorithms for the requested computation;
  - fills the cache in the elements.

Once the <b>cache handler</b> is created, we declare the quantity we need by
passing the appropriate flags.
\snippet example_03.cpp basis_loop_set

\note
<div class="row">
  <a href="#hide21" class="hide" id="hide21">Show note about the Flags</a>
  <a href="#show21" class="show" id="show21">Hide note</a>
  <div class="list">
  Each element family has its own set of admissible flags that represents meaningful quantities
  for the element. The following table shows the association between the base class for each element family 
  and the correspondent flag type:
  <center>
  Elements Family | BaseClass | Flags
  ----------------|--------------|--------------------
  Grid            | GridElement  | grid_element::Flags
  Space           | SpaceElement | space_element::Flags
  Domain          | DomainElement| domain_element::Flags
  GridFunction    | GridFunctionElement | grid_function_element::Flags
  FunctionElement | FunctionElement | function_element::Flags  
  </center>
  Multiple flags of the same type can be combined with the <em>bitwise operator |</em>. 
  For example, if we want to compute the quadrature weights AND the quadrature points mapped
  in the element, we must use:
  \code{.cpp}
  const auto flag = grid_element::Flags::weight | grid_element::Flags::point;
  cache_handler->set_element_flags(flag);
  \endcode
  </div>
</div>

After the call of the method GridHandler::set_element_flags, 
we need to pass the element variable we we want to use (<tt>basis_el</tt>) and
the Quadrature (i.e. the evaluation points scheme). In this example we set a simple
one-point quadrature scheme. We refer to the QGauss class documentation for additional
details. This lines will allocate or resize the cache in the element for all the 
requested quantities.
\snippet example_03.cpp basis_loop_init
\note If the requested quantities or the quadrature points will not change from element to element,
this function can be called once for all.

Inside the loop on an element, we call a function to fill the 
the element values that are going to be requested. 
This function is the one that performs the heavy computations and it is usually the more 
computationally expensive between the set/init/fill trio.
\snippet example_03.cpp fill_cache

Now we can request the weighted measure, this is at each quadrature point
assign the w_i times the measure (length, area, volume) of the element.
\snippet example_03.cpp get_meas


In the second function, the only differences are that we create a BSpline object 
(see \ref example_01)
and then in the element-iterator we compute and ask for the value of the basis function that are non-zero
over the element:
\snippet example_03.cpp basis_values
\note Note also the use of the space_element::Flags::value in the 
SpaceElementHandler::set_element_flags() 
function
\snippet example_03.cpp set_basis_flags


\section Exercises 
-# Different grids (non-uniform, etc.)
-# Different quad schemes with different numbers of points
-# What happens if you request an uninitilized data
-# What happens if you request an data and forgot to fill the value?
\section fcode03 The full program
\include example_03_no_tag.cpp
 
 
 
 
  
*/
