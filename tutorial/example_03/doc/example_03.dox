/**

\page example_03 Example 3: traversing elements of a grid-like container (using values cache)
\section Introduction
In example \ref example_02 we accessed element information on grid-like containers
that do not use a cache.
igatools is a scientific computing library that aims for efficiency.
Unfortunately, efficient and clear code are many times opposite and some sort
of tradeoff is necessary.
In igatools, in order to attain some effiency in the computation we have adopted
a cache mechanism, that requires some minimal extra lines of codes,
an initialization and a filling.
The use of the cache, generally refered in igatools as the element values is
associated to the computation of quantities coming from a quadrature scheme.

\section code03 Description of the program

This example contains two function bodies, plus the main():
- one function (called loop_on_grid_with_cache()) iterates over the element in a Grid and compute/retrieves quadrature weights 
for each element;
- the second function (called loop_on_basis_with_cache()) iterates over the element in a BSpline basis and compute/retrieves the 
values of the basis function that are non-zero on each element;

Besides header files that have been already included in the
previous examples we include a new one for quadrature schemes
\snippet example_03.cpp quad include

For the first function,
similarly to the previous example, we create a grid and define element iterators
pointing to the begining and end of the container
\snippet example_03.cpp loop_as_before

In order to use the cache mechanism, we need to create the <b>cache handler</b>
associated with the container we want to traverse (a Grid object in this case).
\snippet example_03.cpp create_handler
The <b>cache handler</b> basically performs the following tasks:
  - stores the information about which quantities are requested by the user. 
    These quantities are always associated to evaluation points over the element;
  - extracts from the container the data that are needed for the evaluation of the requested quantities;
  - organizes the computation in a way that if the same data is needed multiple times, the
    data is reused and not recomputed; 
  - initialize/resize the cache stored in the element;
  - implements and runs the algorithms for the requested computation;
  - fills the cache in the elements.

Once the <b>cache handler</b> is created we declare the quantity we are interested to 
compute and retrieve. For example, let suppose we want to compute the quadrature weights 
associated to the element (that are the quadrature weights on the \f$[0,1]^{dim}\f$ 
<tt>dim</tt>-dimensional hypercube multiplied by the element measure), then we need to use the 
<b>flag</b> grid_element::Flags::weight
\snippet example_03.cpp set_cache

\note
<div class="row">
  <a href="#hide21" class="hide" id="hide21">Show note about the Flags</a>
  <a href="#show21" class="show" id="show21">Hide note</a>
  <div class="list">
  Each element family has its own set of admissible flags that represents meaningful quantities
  for the element. The following table shows the association between the base class for each element family 
  and the correspondent flag type:
  <center>
  Elements Family | BaseClass | Flags
  ----------------|--------------|--------------------
  Grid            | GridElement  | grid_element::Flags
  Space           | SpaceElement | space_element::Flags
  Domain          | DomainElement| domain_element::Flags
  GridFunction    | GridFunctionElement | grid_function_element::Flags
  FunctionElement | FunctionElement | function_element::Flags  
  </center>
  Multiple flags of the same type can be combined with the <em>bitwise operator |</em>. 
  For example, if we want to compute the quadrature weights AND the quadrature points mapped
  in the element, we must use:
  \code{.cpp}
  const auto flag = grid_element::Flags::weight | grid_element::Flags::point;
  cache_handler->set_element_flags(flag);
  \endcode
  </div>
</div>


After the call of the function GridElementHandler::set_element_flags, 
we need to communicate which is the element that we want to use and which is the Quadrature
(i.e. the evaluation points scheme) we'll use on the element 
(in the example is used the Gaussian quadrature with 2 point along each direction, 
see the documnetation of the class QGauss). 
This action will initialize/resize the cache in the element for all the 
quantities that are needed for the computation.
\snippet example_03.cpp init_cache
\note If the requested quantities or the quadrature points will not change from element to element,
this function can be called only one time.

Inside the loop on an element, we call a function to fill the 
the element values that are going to be requested. 
This function is the one that performs the heavy computations and it is usually the more 
computationally expensive between the set/init/fill trio.
\snippet example_03.cpp fill_cache

Now we can request the weighted measure, this is at each quadrature point
assign the w_i times the measure (length, area, volume) of the element.
\snippet example_03.cpp get_meas


In second function, the only differences are that we create a BSpline object 
(see \ref example_01)
and then in the element-iterator we compute and ask for the value of the basis function that are non-zero
over the element:
\snippet example_03.cpp basis_values
\note Note also the use of the space_element::Flags::value in the SpaceElement::set_element_flags() 
function
\snippet example_03.cpp set_basis_flags


\section Exercises 
-# Different grids (non-uniform, etc.)
-# Different quad schemes with different numbers of points
-# What happens if you request an uninitilized data
-# What happens if you request an data and forgot to fill the value?
\section fcode03 The full program
\include example_03_no_tag.cpp
 
 
 
 
  
*/
