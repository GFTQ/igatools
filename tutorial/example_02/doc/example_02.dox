/**

\page example_02 Example 2: traversing elements of a grid-like container

\section Introduction
In igatools we access information on a Grid or a BSpline
at the element level, using iterators.
This example shows how we loop and access information on elements of grid like 
containers.
igatools classify the information that can be requested on the element
in two categories:
- does not use a cache (so computed directly)
- requires the use of cache for efficient computations

In this example we request information that does not use a cache,
while in example \ref example_03 we treat the access to information
that uses the cache.
See also \ref Infrastructure for more advance information about the topic.


At the same time this example begins to illustrate a recurrent theme in igatools,
attaining dimension independent code, in this case by the use of templated 
functions.

\section code02 Description of the program
We are going to create a cartesian grid and B-spline space so we need 
the includes of example_01
\snippet example_02.cpp old_includes

In igatools, most of the classes have some print/log capability, for this reason
we need to instantiate an object (of tipe LogStream) that is needed for printing information
on a stream (screen, file, etc.)
\snippet example_02.cpp logstream

To loop or iterate on the containers (Grid and BSpline) we 
also need to include the element accessors. 
\snippet example_02.cpp acc_includes

We approach this program to attain dimension independent functions, 
for that we define a <tt>dim</tt> templated function
\snippet example_02.cpp templated_function

This function creates a grid as in example_01
\snippet example_02.cpp create_grid
and iterates (traverse) the elements of the Grid
\snippet example_02.cpp iter_grid
<tt>elem</tt> is a const-reference to a GridElement object, i.e. an <em>element-accessor</em> 
to a Grid container. 
The element-accessor can be asked for information concerning the element currently pointed to.

In the next function we create a SplineSpace and a BSpline basis, then we iterate
over the elements to get some information about the basis function that are non-zero on the element itself.

As before, the function is templetized with a parameter that refers to the topological dimension 
of the grid
\snippet example_02.cpp loop_on_space
In the body of the function
we create a SplineSpace object (defined over a certain Grid) and a BSpline basis (as in the \ref example_01)
\snippet example_02.cpp basis_creation
As for the Grid, also the BSpline object can be iterated. For the moment, the only available iterator
provide a traversal mechanism over the (Bezier) element in the space: the class that represents those 
elements, and returned when the iterator is dereferenced, is BSplineElement. 

The BSplineElement class represents an element in the space with the associated non-zero B-Spline basis functions and, 
among other things, can be queried about the (global) numbering of the active basis functions that have 
support over the element.
\snippet example_02.cpp iter_basis

\section note Note on the spline space and basis functions creation
In the current example (as in \ref example_01) we have created an instance of the SplineSpace class (and BSpline basis)
using the syntax
\code{.cpp}
  auto space = SplineSpace<dim>::create(degree, grid);
  auto basis = BSpline<dim>::create(space);
\endcode
this is an abbreviation for the full template arguments
\code{.cpp}
  auto space = SplineSpace<dim,1,1>::create(degree, grid);
  auto basis = BSpline<dim,1,1>::create(space);
\endcode
where the 3 template arguments represent (from left to right): 
<tt>dimension</tt>, <tt>range</tt> and <tt>rank</tt> of a function belonging from the space.
In other words, if we create something like this
\code{.cpp}
  auto space = SplineSpace<dim,range,rank>::create(degree, grid);
  auto basis = BSpline<dim,range,rank>::create(space);
\endcode
then a basis function \f$\phi_i\f$ maps \f$ \text{dom} \; \phi_i \subseteq \mathbb{R}^{dim} \f$ to
\f$ \underbrace{\mathbb{R}^{range} \times \dots \times \mathbb{R}^{range} }_{ rank \; \text{times} } \f$.
This means that the basis functions in the current example are 
\f$\phi_i  \colon \text{dom} \; \phi_i \subseteq \mathbb{R}^{dim} \to \mathbb{R} \f$.

 

\section Exercise 
<ol>
<li> Modify the functions so that the degree and number of knots
are passed as arguments, and test it with different grids, degrees, etc.
<li> Check the documentation of GridElement and
BSplineElement for other information (without use of cache)
you can ask the element iterator for.
<div class="row">
 <a href="#hide21" class="hide" id="hide21">Show hint</a>
 <a href="#show21" class="show" id="show21">Hide hint</a>
 <div class="list">
\code{.cpp}
elem.is_boundary()
\endcode
 </div>
 </div>
</ol>

\section fcode02 The full program
\include example_02_no_tag.cpp
 
  
*/
