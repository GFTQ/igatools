/**

\page example_02 Example 2: creating domains and plots

\section Introduction
In this example we will create reference domains for each dimension of interest, and the
standard bidimensional domain in the Isogeoemtric Analysis literature, the quarter annulus:
\f{equation}{
  \Omega = \left\{(x,y)\in\mathbb{R}^2| 1\leq x^2+y^2 \leq4,\,
  x\geq0,\,y\geq0\right\}.
\f}
It can be represented with appropriate %NURBS basis functions of degrees 2,1
over a grid of one single element. This means that \f$3\times 2\f$ control points
\f$\{C_{i,j}\}_{i,j=1}^{3,2}\subset\mathbb{R}^2\f$ are required:

<table>
  <tr>
    <td>\f$i/j\f$</td>
    <td>1</td>
    <td>2</td> 
    <td>3</td>
  </tr>
  <tr>
    <td>1</td>
    <td>(1,0)</td>
    <td>(1,1)</td> 
    <td>(0,1)</td>
  </tr>
  <tr>
    <td>2</td>
    <td>(2,0)</td>
    <td>(2,2)</td> 
    <td>(0,2)</td>
  </tr>
</table>

and weights \f$\{w_{i,j}\}_{i,j=1}^{3,2}\subset\mathbb{R}\f$:
<table>
  <tr>
    <td>\f$i/j\f$</td>
    <td>1</td>
    <td>2</td> 
    <td>3</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>\f$\sqrt{2}/2\f$</td> 
    <td>1</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1</td>
    <td>\f$\sqrt{2}/2\f$</td> 
    <td>1</td>
  </tr>
</table>

Once we have the domains, we will save them in a <tt>*.vtk</tt> file. For the quarter
annulus domain, we will create a B-spline space over it and add to the <tt>*.vtk</tt> file
 a data field of a sample basis function. Each domain, eventually with
additional fields, can be visualized with Paraview.


\section code02 Description of the program
Along with the headers of the \ref example_01, we need headers for %NURBS spaces,
functions and the class in charge of saving data for Paraview:
\snippet example_02.cpp headers

We then declare a simple templated function for the creation of trivial physical
domains, i.e. the patch (or reference domain) itself:
\snippet example_02.cpp hypercube
Despite the simplicity of this function, we notice that in igatools a physical
domain is represented as image of a function defined over the grid, in consistency with
the mathematical definition:
\f{equation}{
  \mathbf{F}:[0,1]^\textrm{dim}\longrightarrow \mathbb{R}^{\textrm{dim}},
  \qquad\qquad
  \Omega = \mathbf{F}\left([0,1]^\textrm{dim}\right)
\f}
Hence the creation of a trivial domain requires a trivial geometric function.
The class GridFunction represents functions defined on the reference domain only,
i. e. they are defined on Grid objects. As we will see later in this exercise, any other function with
a different domain is represented by the Function class.

We now want to create the quarter annulus geometry with specfic instances of
the templated classes it uses. As for the reference domain, we delegate a function
for the creation:
\snippet example_02.cpp annulus_init
The IgCoefficients is a class for spline coefficients storage. It can be thought
as an <tt>std::map<Index,Real></tt> where Index is the global index of the degree
of freedom and works as the map key. More interestingly, we notice that igatools
adopts the following convention for index ordering of vector fields: first the component 
\f$x\f$, then the component \f$y\f$ and so on. Each component is listed
with the same logical ordering: first the values along the \f$u\f$ axis, then
the \f$v\f$ axis and so on. Each basis function, whether it is a B-spline or a
%NURBS, accepts scalar coefficients only. As first step of the creation of the annulus, 
we need a grid of 1 element, i.e. a grid of two knots.

%NURBS-based geometric functions are linear combination of weighted B-splines and control
points, divided by the so-called weight function. Hence, we first need
a scalar BSpline space and then we can create the weight function:
\snippet example_02.cpp weight_funct
\note
In the current example (as in \ref example_01) we have created an instance of the SplineSpace class (and BSpline basis)
using the syntax
\code{.cpp}
  auto space = SplineSpace<dim>::create(degree, grid);
  auto basis = BSpline<dim>::create(space);
\endcode
It is a convenient abbreviation for the full template arguments specification
\code{.cpp}
  auto space = SplineSpace<dim,1,1>::create(degree, grid);
  auto basis = BSpline<dim,1,1>::create(space);
\endcode
where the 3 template arguments represent (from left to right): 
<tt>dimension</tt>, <tt>range</tt> and <tt>rank</tt> of a function belonging to the space.
In other words, if we create these objects
\code{.cpp}
  auto space = SplineSpace<dim,range,rank>::create(degree, grid);
  auto basis = BSpline<dim,range,rank>::create(space);
\endcode
then a basis function \f$\phi_i\f$ maps \f$ \text{dom} \; \phi_i \subseteq \mathbb{R}^{dim} \f$ to
\f$ \underbrace{\mathbb{R}^{range} \times \dots \times \mathbb{R}^{range} }_{ rank \; \text{times} } \f$.
Along with tensor fields, igatools supports numerical analysis on manifolds, so that
certain objects such as PhysicalSpaceBasis require the four integer template parameters
<tt>dimension</tt>, <tt>codimension</tt>, <tt>range</tt> and <tt>rank</tt>, where
the codimension is the difference between the manifold dimension and the embedding space
dimension.

Now we can proceed with the construction of the NURBS vector space and the
geometric IgGridFunction, with a more specific template declaration:
\snippet example_02.cpp geom_funct

%A \f$1\times1\f$ element grid is elegant but too coarse for Finite %Element Analysis,
therefore we proceed to refine and then we create the domain:
\snippet example_02.cpp refinement
By design choice, igatools objects belonging to the same conceptual group are all
linked: spline spaces, B-spline basis, functions, grid functions or domains created
from the same grid (directly or indirectly) belong to the same refinement group.
This means that whenever an object is \f$h\f$-refined (via knot insertion), any
other member of the group is automatically refined. This works either upward and downward in the
creation hierarchy. Moreover, if an object is created from a refinement group,
it is created with the last level of refinement. Finally, we notice that
we used only non const creators, as the objects have to be modified for the
refining process. Objects created with the <tt>const_create</tt> methods cannot
be refined.

We have now functions for the creation of geometries. They can be beholded in action
in the first lines of the <tt>main</tt> function:
\snippet example_02.cpp main

Saving the geometries is a straightforward procedure. Given the number of plot points
per element, the class Writer is in charge of saving the data:
\snippet example_02.cpp cube_plot

We want now to save the annulus domain with an example of a B-spline basis function
on it. In order to do so we need a PhysicalSpaceBasis on the annulus. Its creation
follows the usual creation procedure: Grid, SplineSpace, BSpline, PhysicalSpaceBasis:
\snippet example_02.cpp basis

In order to plot a single basis function, we create an IgFunction whose coefficients
are all zero but the one associated to the basis function. We first get the DofDistribution
class from the physical space. This class is responsible for indexes management.
Now we can create another instance of IgCoefficients with the global indexes as
keys given back from the method <tt>get_global_dofs()</tt>. By default, the values
are all zeroed. Setting to 1.0 the coefficient of the desired basis function is the
only thing that remains before creating the IgFunction:
\snippet example_02.cpp basis_funct

We are close to the end of the exercise: we need to construct a new Writer and
then simply add via the <tt>add_field</tt> method the Function object we want to plot.
\snippet example_02.cpp annulus_plot

\section Exercise 
<ol>
<li> Modify the functions so that the degree and number of knots
are passed as arguments, and test it with different grids, degrees, etc.
<li> Check the documentation of GridElement and
BSplineElement for other information (without use of cache)
you can ask the element iterator for.
<div class="row">
 <a href="#hide21" class="hide" id="hide21">Show hint</a>
 <a href="#show21" class="show" id="show21">Hide hint</a>
 <div class="list">
\code{.cpp}
elem.is_boundary()
\endcode
 </div>
 </div>
</ol>

\section fcode02 The full program
\include example_02_no_tag.cpp
 
  
*/
