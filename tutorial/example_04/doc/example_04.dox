/**

\page example_04 Example 4: plotting a BSpline basis function

\section Introduction

In this program we'll build (and save in a file for plotting) a basis function 
\f$ \hat{\varphi}_j \colon \mathbb{R}^{dim} \to \mathbb{R} \f$ 
of a given B-Spline space \f$ \hat{\mathbb{V}}_h(\hat{\Omega}) = 
\text{span}\{ \hat{\varphi}_i \colon \hat{\Omega} \to \mathbb{R} \; , i = 1,\dots,n_h \}\f$, with 
\f$\hat{\Omega} = [0,1]^{dim} \subset \mathbb{R}^{dim}\f$.

A function \f$\hat{f} \in \hat{\mathbb{V}}_h(\hat{\Omega})\f$ can be expressed as
linear combination of basis function:
\f{equation}{
	\hat{f} = \sum_{i=1}^{n_h} a_i(\hat{f}) \hat{\varphi}_i \label{eq:func_ref}
\f} 
where the real numbers \f$ a_1(\hat{f}),\dots, a_{n_h}(\hat{f}) \f$ are the coefficients of 
\f$ \hat{f}\f$ in the basis \f$ \bigl\{ \hat{\varphi}_i \bigr\}_{i=1}^{n_h} \f$.
This means that the basis function \f$ \hat{\varphi}_j \f$ can be expressed as
\f$ \hat{\varphi}_j = \sum_{i=1}^{n_h} a_i(\hat{\varphi}_j) \hat{\varphi}_i \f$
where  \f$ a_i(\hat{\varphi}_j) = \delta_{ij}\f$, i.e. is 0 if \f$ i\neq j \f$ 
and is 1 if \f$ i= j \f$.

Why this boring introduction? The fact is that in igatools there is a class (IgGridFunction)
that represents functions that are linear combination of BSpline (or NURBS) basis function,
 as in eq.(1).

Let's see how to use the IgGridFunction class in order to plot a basis function.


   
\section code04 Description of the program
In the include list there is only one new header 
with respect to the headers of \ref example_01, namely
\snippet example_04.cpp new include
where the IgGridFunction is declared

We define a <tt>dim</tt>-templated function that creates a uniformly distributed
maximum regularity open knot spline space of a given degree.
To obtain at least one basis function that is not affected by the 
boundary we consider deg+2 knots in each direction.
\snippet example_04.cpp plot_function
Then we use the grid to create the SplineSpace and the BSpline basis
\snippet example_04.cpp create_basis

For storing the coefficient of the linear combination, we use the class IgCoefficients
that maps the global ids of the basis function with the associated coefficient. Then 
we need to build an instance of the IgCoefficients class and initialize the coefficients associated to 
the basis function to zero: in order to do so we need get the DofDistribution 
(that contains the information about the dofs of the SplineSpace) and extract the global dofs
to construct an IgCoefficients object
\snippet example_04.cpp init_vec

To get the "central" basis function we address it by its tensor index, but
the coefficient vector only knows about (global) flat indices.
The tensor index is hardcoded to the space while the flat index depends on the
the degree of freedom distribution policy (represented by the class DofDistribution):
\snippet example_04.cpp tensor_to_flat
Just to double check we print the vector on the screen
\snippet example_04.cpp print_vector

Now we can build the object representing the selected basis function: for this we use the 
object representing the BSpline basis and the coefficients of the function in that basis:
\snippet example_04.cpp basis_to_plot

And we plot the basis function using <tt>n_plot_points</tt> for each element of the grid.
\snippet example_04.cpp plot_basis
If you run the code you should have the following <tt>.vtu</tt> files:
- <tt>bspline_basis-2_1d.vtu</tt> that refers to <tt>dim==1</tt>
- <tt>bspline_basis-12_2d.vtu</tt> that refers to <tt>dim==2</tt>
- <tt>bspline_basis-62_3d.vtu</tt> that refers to <tt>dim==3</tt>

that can be visualized using [Paraview](http://www.paraview.org)

\section Exercises 
-# test with other degrees
-# modify the function plot_basis(const int deg) so that it plots all
   basis functions of the space
\section fcode04 The full program
\include example_04_no_tag.cpp
 
  
*/
